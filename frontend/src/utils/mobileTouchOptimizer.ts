/**
 * Mobile Touch Optimizer and Spatial Animation System (T5.3)
 * 
 * Advanced mobile UX features including touch-responsive animations,
 * spatial particle density optimization, orientation management,
 * and haptic feedback integration.
 */

import type { MobileCapabilities } from './mobileDetection';

export interface TouchInteractionEvent {
  id: string;
  type: 'start' | 'move' | 'end' | 'cancel';
  timestamp: number;
  clientX: number;
  clientY: number;
  screenX: number;
  screenY: number;
  force?: number;
  radiusX?: number;
  radiusY?: number;
  rotationAngle?: number;
  velocity?: { x: number; y: number };
  acceleration?: { x: number; y: number };
}

export interface SpatialZone {
  id: string;
  bounds: {
    left: number;
    top: number;
    right: number;
    bottom: number;
  };
  particleDensity: number;
  animationIntensity: number;
  interactionRadius: number;
  enabled: boolean;
}

export interface TouchResponsiveSettings {
  enableTouchParticles: boolean;
  touchParticleCount: number;
  touchParticleLifetime: number;
  touchRippleEffect: boolean;
  touchTrailEffect: boolean;
  touchGravityEffect: boolean;
  touchRepulsionEffect: boolean;
  interactionRadius: number;
  forceMultiplier: number;
  velocityDecay: number;
}

export interface SpatialOptimizationSettings {
  enableSpatialZones: boolean;
  adaptToDensity: boolean;
  maxZones: number;
  minParticlesPerZone: number;
  maxParticlesPerZone: number;
  densityThreshold: number;
  redistributionEnabled: boolean;
  performanceBasedCulling: boolean;
}

export interface OrientationSettings {
  enableOrientationResponse: boolean;
  smoothTransitions: boolean;
  gravitationalEffect: boolean;
  landscapeOptimizations: boolean;
  portraitOptimizations: boolean;
  transitionDuration: number;
}

export interface HapticSettings {
  enableHaptics: boolean;
  touchFeedback: boolean;
  interactionFeedback: boolean;
  intensityLevels: {
    light: number;
    medium: number;
    heavy: number;
  };
}

/**
 * Mobile touch optimizer for responsive animations
 */
export class MobileTouchOptimizer {
  private isActive = false;
  private mobileCapabilities: MobileCapabilities | null = null;
  private touchEvents: TouchInteractionEvent[] = [];
  private spatialZones: Map<string, SpatialZone> = new Map();
  private activeInteractions: Map<number, TouchInteractionEvent> = new Map();
  
  // Settings\n  private touchSettings: TouchResponsiveSettings;\n  private spatialSettings: SpatialOptimizationSettings;\n  private orientationSettings: OrientationSettings;\n  private hapticSettings: HapticSettings;\n  \n  // Touch tracking\n  private lastTouchPositions: Map<number, { x: number; y: number; timestamp: number }> = new Map();\n  private touchVelocities: Map<number, { x: number; y: number }> = new Map();\n  \n  // Spatial optimization\n  private viewportDimensions = { width: 0, height: 0 };\n  private currentOrientation: 'portrait' | 'landscape' = 'portrait';\n  private densityMap: number[][] = [];\n  private lastDensityUpdate = 0;\n  \n  // Performance tracking\n  private interactionCount = 0;\n  private lastPerformanceCheck = 0;\n  private frameBudget = 16.67; // 60fps target\n  \n  constructor(settings: Partial<{\n    touch: Partial<TouchResponsiveSettings>;\n    spatial: Partial<SpatialOptimizationSettings>;\n    orientation: Partial<OrientationSettings>;\n    haptic: Partial<HapticSettings>;\n  }> = {}) {\n    this.touchSettings = {\n      enableTouchParticles: true,\n      touchParticleCount: 5,\n      touchParticleLifetime: 2000,\n      touchRippleEffect: true,\n      touchTrailEffect: true,\n      touchGravityEffect: false,\n      touchRepulsionEffect: true,\n      interactionRadius: 100,\n      forceMultiplier: 1.0,\n      velocityDecay: 0.95,\n      ...settings.touch\n    };\n    \n    this.spatialSettings = {\n      enableSpatialZones: true,\n      adaptToDensity: true,\n      maxZones: 6,\n      minParticlesPerZone: 2,\n      maxParticlesPerZone: 8,\n      densityThreshold: 0.3,\n      redistributionEnabled: true,\n      performanceBasedCulling: true,\n      ...settings.spatial\n    };\n    \n    this.orientationSettings = {\n      enableOrientationResponse: true,\n      smoothTransitions: true,\n      gravitationalEffect: true,\n      landscapeOptimizations: true,\n      portraitOptimizations: true,\n      transitionDuration: 500,\n      ...settings.orientation\n    };\n    \n    this.hapticSettings = {\n      enableHaptics: true,\n      touchFeedback: true,\n      interactionFeedback: true,\n      intensityLevels: {\n        light: 0.2,\n        medium: 0.5,\n        heavy: 0.8\n      },\n      ...settings.haptic\n    };\n    \n    this.updateViewportDimensions();\n    this.initializeSpatialZones();\n  }\n  \n  /**\n   * Initialize mobile touch optimization\n   */\n  async initialize(mobileCapabilities: MobileCapabilities): Promise<void> {\n    this.mobileCapabilities = mobileCapabilities;\n    this.isActive = true;\n    \n    // Optimize settings based on device capabilities\n    this.optimizeSettingsForDevice();\n    \n    // Setup event listeners\n    this.setupTouchEventListeners();\n    this.setupOrientationListeners();\n    this.setupViewportListeners();\n    \n    // Initialize spatial optimization\n    this.initializeDensityMap();\n    \n    console.log('Mobile touch optimizer initialized');\n  }\n  \n  /**\n   * Optimize settings based on device capabilities\n   */\n  private optimizeSettingsForDevice(): void {\n    if (!this.mobileCapabilities) return;\n    \n    const { gpuMemoryMB, maxTextureSize, viewportSize } = this.mobileCapabilities;\n    \n    // Reduce particle counts for low-end devices\n    if (gpuMemoryMB && gpuMemoryMB < 512) {\n      this.touchSettings.touchParticleCount = Math.min(this.touchSettings.touchParticleCount, 3);\n      this.spatialSettings.maxParticlesPerZone = Math.min(this.spatialSettings.maxParticlesPerZone, 4);\n    }\n    \n    // Adjust interaction radius for screen size\n    if (viewportSize.width < 414) { // Small mobile screens\n      this.touchSettings.interactionRadius = Math.min(this.touchSettings.interactionRadius, 60);\n    }\n    \n    // Disable expensive effects on very low-end devices\n    if (maxTextureSize && maxTextureSize < 2048) {\n      this.touchSettings.touchTrailEffect = false;\n      this.touchSettings.touchGravityEffect = false;\n    }\n    \n    // Enable haptics only if supported\n    if (!this.mobileCapabilities.touchSupport) {\n      this.hapticSettings.enableHaptics = false;\n    }\n  }\n  \n  /**\n   * Setup touch event listeners\n   */\n  private setupTouchEventListeners(): void {\n    const handleTouchStart = (event: TouchEvent) => {\n      if (!this.isActive) return;\n      \n      for (let i = 0; i < event.changedTouches.length; i++) {\n        const touch = event.changedTouches[i];\n        const touchEvent = this.createTouchInteractionEvent('start', touch);\n        \n        this.touchEvents.push(touchEvent);\n        this.activeInteractions.set(touch.identifier, touchEvent);\n        this.lastTouchPositions.set(touch.identifier, {\n          x: touch.clientX,\n          y: touch.clientY,\n          timestamp: touchEvent.timestamp\n        });\n        \n        // Trigger haptic feedback\n        if (this.hapticSettings.enableHaptics && this.hapticSettings.touchFeedback) {\n          this.triggerHapticFeedback('light');\n        }\n        \n        // Update spatial zones\n        this.updateSpatialZonesForTouch(touchEvent);\n      }\n      \n      this.cleanupOldTouchEvents();\n    };\n    \n    const handleTouchMove = (event: TouchEvent) => {\n      if (!this.isActive) return;\n      \n      for (let i = 0; i < event.changedTouches.length; i++) {\n        const touch = event.changedTouches[i];\n        const touchEvent = this.createTouchInteractionEvent('move', touch);\n        \n        // Calculate velocity\n        const lastPos = this.lastTouchPositions.get(touch.identifier);\n        if (lastPos) {\n          const deltaTime = touchEvent.timestamp - lastPos.timestamp;\n          if (deltaTime > 0) {\n            const velocity = {\n              x: (touch.clientX - lastPos.x) / deltaTime,\n              y: (touch.clientY - lastPos.y) / deltaTime\n            };\n            \n            touchEvent.velocity = velocity;\n            this.touchVelocities.set(touch.identifier, velocity);\n          }\n        }\n        \n        this.touchEvents.push(touchEvent);\n        this.activeInteractions.set(touch.identifier, touchEvent);\n        this.lastTouchPositions.set(touch.identifier, {\n          x: touch.clientX,\n          y: touch.clientY,\n          timestamp: touchEvent.timestamp\n        });\n        \n        // Update spatial zones\n        this.updateSpatialZonesForTouch(touchEvent);\n      }\n    };\n    \n    const handleTouchEnd = (event: TouchEvent) => {\n      if (!this.isActive) return;\n      \n      for (let i = 0; i < event.changedTouches.length; i++) {\n        const touch = event.changedTouches[i];\n        const touchEvent = this.createTouchInteractionEvent('end', touch);\n        \n        // Apply final velocity if available\n        const velocity = this.touchVelocities.get(touch.identifier);\n        if (velocity) {\n          touchEvent.velocity = velocity;\n        }\n        \n        this.touchEvents.push(touchEvent);\n        this.activeInteractions.delete(touch.identifier);\n        this.lastTouchPositions.delete(touch.identifier);\n        this.touchVelocities.delete(touch.identifier);\n        \n        // Trigger interaction feedback\n        if (this.hapticSettings.enableHaptics && this.hapticSettings.interactionFeedback) {\n          this.triggerHapticFeedback('medium');\n        }\n      }\n    };\n    \n    // Use passive listeners for better performance\n    document.addEventListener('touchstart', handleTouchStart, { passive: true });\n    document.addEventListener('touchmove', handleTouchMove, { passive: true });\n    document.addEventListener('touchend', handleTouchEnd, { passive: true });\n    document.addEventListener('touchcancel', handleTouchEnd, { passive: true });\n  }\n  \n  /**\n   * Create touch interaction event\n   */\n  private createTouchInteractionEvent(\n    type: 'start' | 'move' | 'end' | 'cancel',\n    touch: Touch\n  ): TouchInteractionEvent {\n    return {\n      id: `touch-${touch.identifier}-${Date.now()}`,\n      type,\n      timestamp: performance.now(),\n      clientX: touch.clientX,\n      clientY: touch.clientY,\n      screenX: touch.screenX,\n      screenY: touch.screenY,\n      force: touch.force,\n      radiusX: touch.radiusX,\n      radiusY: touch.radiusY,\n      rotationAngle: touch.rotationAngle\n    };\n  }\n  \n  /**\n   * Setup orientation change listeners\n   */\n  private setupOrientationListeners(): void {\n    const handleOrientationChange = () => {\n      if (!this.orientationSettings.enableOrientationResponse) return;\n      \n      const newOrientation = window.innerWidth > window.innerHeight ? 'landscape' : 'portrait';\n      \n      if (newOrientation !== this.currentOrientation) {\n        this.currentOrientation = newOrientation;\n        this.updateViewportDimensions();\n        this.reinitializeSpatialZones();\n        \n        console.log(`Orientation changed to: ${newOrientation}`);\n      }\n    };\n    \n    // Listen for orientation changes\n    if (screen.orientation) {\n      screen.orientation.addEventListener('change', handleOrientationChange);\n    }\n    \n    window.addEventListener('orientationchange', handleOrientationChange);\n    window.addEventListener('resize', handleOrientationChange);\n  }\n  \n  /**\n   * Setup viewport listeners\n   */\n  private setupViewportListeners(): void {\n    if ('visualViewport' in window) {\n      window.visualViewport?.addEventListener('resize', () => {\n        this.updateViewportDimensions();\n        this.updateSpatialZonesForViewport();\n      });\n    }\n  }\n  \n  /**\n   * Update viewport dimensions\n   */\n  private updateViewportDimensions(): void {\n    this.viewportDimensions = {\n      width: window.innerWidth || document.documentElement.clientWidth,\n      height: window.innerHeight || document.documentElement.clientHeight\n    };\n  }\n  \n  /**\n   * Initialize spatial zones\n   */\n  private initializeSpatialZones(): void {\n    if (!this.spatialSettings.enableSpatialZones) return;\n    \n    this.spatialZones.clear();\n    \n    const { width, height } = this.viewportDimensions;\n    const zoneCount = Math.min(this.spatialSettings.maxZones, 6);\n    \n    // Create grid-based zones\n    const cols = this.currentOrientation === 'landscape' ? 3 : 2;\n    const rows = Math.ceil(zoneCount / cols);\n    \n    const zoneWidth = width / cols;\n    const zoneHeight = height / rows;\n    \n    for (let row = 0; row < rows; row++) {\n      for (let col = 0; col < cols; col++) {\n        const zoneId = `zone-${row}-${col}`;\n        const zone: SpatialZone = {\n          id: zoneId,\n          bounds: {\n            left: col * zoneWidth,\n            top: row * zoneHeight,\n            right: (col + 1) * zoneWidth,\n            bottom: (row + 1) * zoneHeight\n          },\n          particleDensity: 0.5,\n          animationIntensity: 0.5,\n          interactionRadius: this.touchSettings.interactionRadius,\n          enabled: true\n        };\n        \n        this.spatialZones.set(zoneId, zone);\n      }\n    }\n  }\n  \n  /**\n   * Reinitialize spatial zones after orientation change\n   */\n  private reinitializeSpatialZones(): void {\n    if (this.orientationSettings.smoothTransitions) {\n      // Gradually transition zones\n      setTimeout(() => {\n        this.initializeSpatialZones();\n      }, this.orientationSettings.transitionDuration);\n    } else {\n      this.initializeSpatialZones();\n    }\n  }\n  \n  /**\n   * Initialize density map for spatial optimization\n   */\n  private initializeDensityMap(): void {\n    const { width, height } = this.viewportDimensions;\n    const resolution = 20; // 20x20 grid\n    \n    this.densityMap = [];\n    for (let y = 0; y < resolution; y++) {\n      this.densityMap[y] = [];\n      for (let x = 0; x < resolution; x++) {\n        this.densityMap[y][x] = 0;\n      }\n    }\n  }\n  \n  /**\n   * Update spatial zones based on touch interaction\n   */\n  private updateSpatialZonesForTouch(touchEvent: TouchInteractionEvent): void {\n    if (!this.spatialSettings.enableSpatialZones) return;\n    \n    const { clientX, clientY } = touchEvent;\n    \n    // Find zones affected by this touch\n    for (const [zoneId, zone] of this.spatialZones) {\n      const { bounds } = zone;\n      \n      // Check if touch is within zone or interaction radius\n      const distanceToZone = this.getDistanceToZone(clientX, clientY, bounds);\n      \n      if (distanceToZone <= zone.interactionRadius) {\n        // Increase density and animation intensity\n        const intensity = 1 - (distanceToZone / zone.interactionRadius);\n        zone.particleDensity = Math.min(1, zone.particleDensity + intensity * 0.1);\n        zone.animationIntensity = Math.min(1, zone.animationIntensity + intensity * 0.2);\n        \n        // Update density map\n        this.updateDensityMap(clientX, clientY, intensity);\n      }\n    }\n    \n    // Decay zones that aren't being touched\n    this.decayUnusedZones();\n  }\n  \n  /**\n   * Get distance from point to zone bounds\n   */\n  private getDistanceToZone(\n    x: number,\n    y: number,\n    bounds: { left: number; top: number; right: number; bottom: number }\n  ): number {\n    const { left, top, right, bottom } = bounds;\n    \n    // If point is inside zone, distance is 0\n    if (x >= left && x <= right && y >= top && y <= bottom) {\n      return 0;\n    }\n    \n    // Calculate distance to nearest edge\n    const dx = Math.max(left - x, 0, x - right);\n    const dy = Math.max(top - y, 0, y - bottom);\n    \n    return Math.sqrt(dx * dx + dy * dy);\n  }\n  \n  /**\n   * Update density map\n   */\n  private updateDensityMap(x: number, y: number, intensity: number): void {\n    const { width, height } = this.viewportDimensions;\n    const resolution = this.densityMap.length;\n    \n    const mapX = Math.floor((x / width) * resolution);\n    const mapY = Math.floor((y / height) * resolution);\n    \n    if (mapX >= 0 && mapX < resolution && mapY >= 0 && mapY < resolution) {\n      this.densityMap[mapY][mapX] = Math.min(1, this.densityMap[mapY][mapX] + intensity * 0.1);\n    }\n  }\n  \n  /**\n   * Decay unused zones\n   */\n  private decayUnusedZones(): void {\n    const now = performance.now();\n    \n    if (now - this.lastDensityUpdate > 100) { // Decay every 100ms\n      for (const zone of this.spatialZones.values()) {\n        zone.particleDensity = Math.max(0.1, zone.particleDensity * 0.99);\n        zone.animationIntensity = Math.max(0.1, zone.animationIntensity * 0.98);\n      }\n      \n      // Decay density map\n      for (let y = 0; y < this.densityMap.length; y++) {\n        for (let x = 0; x < this.densityMap[y].length; x++) {\n          this.densityMap[y][x] *= 0.95;\n        }\n      }\n      \n      this.lastDensityUpdate = now;\n    }\n  }\n  \n  /**\n   * Update spatial zones for viewport changes\n   */\n  private updateSpatialZonesForViewport(): void {\n    // Redistribute zones based on new viewport\n    this.initializeSpatialZones();\n  }\n  \n  /**\n   * Trigger haptic feedback\n   */\n  private triggerHapticFeedback(intensity: 'light' | 'medium' | 'heavy'): void {\n    if (!this.hapticSettings.enableHaptics || !navigator.vibrate) return;\n    \n    const intensityValue = this.hapticSettings.intensityLevels[intensity];\n    const duration = Math.round(intensityValue * 50); // Max 40ms vibration\n    \n    try {\n      navigator.vibrate(duration);\n    } catch (error) {\n      // Haptic feedback not supported\n    }\n  }\n  \n  /**\n   * Clean up old touch events\n   */\n  private cleanupOldTouchEvents(): void {\n    const now = performance.now();\n    const maxAge = 5000; // 5 seconds\n    \n    this.touchEvents = this.touchEvents.filter(\n      event => now - event.timestamp < maxAge\n    );\n  }\n  \n  /**\n   * Get current touch interactions\n   */\n  getCurrentTouchInteractions(): TouchInteractionEvent[] {\n    return Array.from(this.activeInteractions.values());\n  }\n  \n  /**\n   * Get recent touch events\n   */\n  getRecentTouchEvents(maxAge = 1000): TouchInteractionEvent[] {\n    const now = performance.now();\n    return this.touchEvents.filter(event => now - event.timestamp < maxAge);\n  }\n  \n  /**\n   * Get spatial zones\n   */\n  getSpatialZones(): SpatialZone[] {\n    return Array.from(this.spatialZones.values());\n  }\n  \n  /**\n   * Get density map\n   */\n  getDensityMap(): number[][] {\n    return this.densityMap.map(row => [...row]); // Deep copy\n  }\n  \n  /**\n   * Get optimal particle count for zone\n   */\n  getOptimalParticleCountForZone(zoneId: string): number {\n    const zone = this.spatialZones.get(zoneId);\n    if (!zone) return 0;\n    \n    const { minParticlesPerZone, maxParticlesPerZone } = this.spatialSettings;\n    const density = zone.particleDensity;\n    \n    return Math.round(\n      minParticlesPerZone + (maxParticlesPerZone - minParticlesPerZone) * density\n    );\n  }\n  \n  /**\n   * Get touch-responsive particle settings\n   */\n  getTouchResponsiveSettings(): TouchResponsiveSettings {\n    return { ...this.touchSettings };\n  }\n  \n  /**\n   * Update settings\n   */\n  updateSettings(settings: Partial<{\n    touch: Partial<TouchResponsiveSettings>;\n    spatial: Partial<SpatialOptimizationSettings>;\n    orientation: Partial<OrientationSettings>;\n    haptic: Partial<HapticSettings>;\n  }>): void {\n    if (settings.touch) {\n      this.touchSettings = { ...this.touchSettings, ...settings.touch };\n    }\n    \n    if (settings.spatial) {\n      this.spatialSettings = { ...this.spatialSettings, ...settings.spatial };\n      if (settings.spatial.enableSpatialZones !== undefined) {\n        this.initializeSpatialZones();\n      }\n    }\n    \n    if (settings.orientation) {\n      this.orientationSettings = { ...this.orientationSettings, ...settings.orientation };\n    }\n    \n    if (settings.haptic) {\n      this.hapticSettings = { ...this.hapticSettings, ...settings.haptic };\n    }\n  }\n  \n  /**\n   * Get performance insights\n   */\n  getPerformanceInsights(): {\n    touchLatency: number;\n    spatialEfficiency: number;\n    interactionDensity: number;\n    recommendations: string[];\n  } {\n    const now = performance.now();\n    const recommendations: string[] = [];\n    \n    // Calculate average touch latency\n    const recentEvents = this.getRecentTouchEvents(1000);\n    const touchLatency = recentEvents.length > 0 \n      ? recentEvents.reduce((acc, event) => acc + (now - event.timestamp), 0) / recentEvents.length\n      : 0;\n    \n    // Calculate spatial efficiency\n    const activeZones = Array.from(this.spatialZones.values()).filter(zone => zone.particleDensity > 0.1);\n    const spatialEfficiency = activeZones.length / this.spatialZones.size;\n    \n    // Calculate interaction density\n    const totalDensity = Array.from(this.spatialZones.values())\n      .reduce((acc, zone) => acc + zone.particleDensity, 0);\n    const interactionDensity = totalDensity / this.spatialZones.size;\n    \n    // Generate recommendations\n    if (touchLatency > 50) {\n      recommendations.push('High touch latency detected, consider reducing touch particle count');\n    }\n    \n    if (spatialEfficiency < 0.3) {\n      recommendations.push('Low spatial efficiency, consider reducing number of zones');\n    }\n    \n    if (interactionDensity > 0.8) {\n      recommendations.push('High interaction density, consider optimizing particle distribution');\n    }\n    \n    return {\n      touchLatency,\n      spatialEfficiency,\n      interactionDensity,\n      recommendations\n    };\n  }\n  \n  /**\n   * Cleanup and deactivate\n   */\n  cleanup(): void {\n    this.isActive = false;\n    this.touchEvents = [];\n    this.activeInteractions.clear();\n    this.lastTouchPositions.clear();\n    this.touchVelocities.clear();\n    this.spatialZones.clear();\n  }\n}\n\n/**\n * Create mobile touch optimizer with default settings\n */\nexport const createMobileTouchOptimizer = (settings?: Partial<{\n  touch: Partial<TouchResponsiveSettings>;\n  spatial: Partial<SpatialOptimizationSettings>;\n  orientation: Partial<OrientationSettings>;\n  haptic: Partial<HapticSettings>;\n}>): MobileTouchOptimizer => {\n  return new MobileTouchOptimizer(settings);\n};