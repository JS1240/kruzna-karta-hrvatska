/**
 * Connection-Aware Mobile Optimizer (T5.3)
 * 
 * Adaptive animation optimization based on network quality,
 * data usage patterns, and connection-specific performance
 * characteristics for mobile devices.
 */

import type { MobileCapabilities, MobileOptimizationSettings } from './mobileDetection';

export interface ConnectionMetrics {
  effectiveType: '2g' | '3g' | '4g' | 'slow-2g';
  downlink: number; // Mbps
  uplink?: number; // Mbps
  rtt: number; // Round trip time in ms
  saveData: boolean;
  type?: 'bluetooth' | 'cellular' | 'ethernet' | 'none' | 'other' | 'unknown' | 'wifi' | 'wimax';
}

export interface DataUsageMetrics {
  totalBytes: number;
  sessionBytes: number;
  animationBytes: number;
  assetBytes: number;
  compressionRatio: number;
  estimatedCost?: number; // In user's currency
}

export interface ConnectionProfile {
  id: string;
  name: string;
  description: string;
  
  // Performance characteristics
  maxParticleCount: number;
  maxFrameRate: number;
  textureQuality: 'low' | 'medium' | 'high';
  enablePreloading: boolean;
  enableCaching: boolean;
  
  // Data optimization
  enableCompression: boolean;
  enableLazyLoading: boolean;
  maxDataBudget: number; // MB per session
  enableOfflineMode: boolean;
  
  // Animation settings
  enableComplexAnimations: boolean;
  enableTransitions: boolean;
  enableBackgroundAnimations: boolean;
  maxAnimationDuration: number;
  
  // Network-specific optimizations
  enableBandwidthAdaptation: boolean;
  enableLatencyCompensation: boolean;
  enableDataSaving: boolean;
  enableProgressiveLoading: boolean;
}

/**\n * Connection-aware optimizer for mobile animations\n */\nexport class ConnectionAwareOptimizer {\n  private static instance: ConnectionAwareOptimizer;\n  private connectionMetrics: ConnectionMetrics | null = null;\n  private dataUsageMetrics: DataUsageMetrics;\n  private currentProfile: ConnectionProfile;\n  private sessionStartTime: number;\n  private lastBandwidthTest: number = 0;\n  private bandwidthHistory: number[] = [];\n  \n  // Connection monitoring\n  private connectionMonitorInterval?: number;\n  private dataUsageCheckInterval?: number;\n  \n  // Predefined connection profiles\n  private readonly profiles: Map<string, ConnectionProfile> = new Map([\n    ['ultra-fast', {\n      id: 'ultra-fast',\n      name: 'Ultra Fast',\n      description: '5G/High-speed WiFi (>50 Mbps)',\n      maxParticleCount: 20,\n      maxFrameRate: 60,\n      textureQuality: 'high',\n      enablePreloading: true,\n      enableCaching: true,\n      enableCompression: false,\n      enableLazyLoading: false,\n      maxDataBudget: 100,\n      enableOfflineMode: false,\n      enableComplexAnimations: true,\n      enableTransitions: true,\n      enableBackgroundAnimations: true,\n      maxAnimationDuration: 10000,\n      enableBandwidthAdaptation: false,\n      enableLatencyCompensation: false,\n      enableDataSaving: false,\n      enableProgressiveLoading: false\n    }],\n    \n    ['fast', {\n      id: 'fast',\n      name: 'Fast',\n      description: '4G/Good WiFi (10-50 Mbps)',\n      maxParticleCount: 16,\n      maxFrameRate: 60,\n      textureQuality: 'high',\n      enablePreloading: true,\n      enableCaching: true,\n      enableCompression: true,\n      enableLazyLoading: false,\n      maxDataBudget: 50,\n      enableOfflineMode: true,\n      enableComplexAnimations: true,\n      enableTransitions: true,\n      enableBackgroundAnimations: true,\n      maxAnimationDuration: 8000,\n      enableBandwidthAdaptation: true,\n      enableLatencyCompensation: false,\n      enableDataSaving: false,\n      enableProgressiveLoading: true\n    }],\n    \n    ['medium', {\n      id: 'medium',\n      name: 'Medium',\n      description: '3G/Regular WiFi (1-10 Mbps)',\n      maxParticleCount: 12,\n      maxFrameRate: 45,\n      textureQuality: 'medium',\n      enablePreloading: false,\n      enableCaching: true,\n      enableCompression: true,\n      enableLazyLoading: true,\n      maxDataBudget: 25,\n      enableOfflineMode: true,\n      enableComplexAnimations: true,\n      enableTransitions: true,\n      enableBackgroundAnimations: false,\n      maxAnimationDuration: 5000,\n      enableBandwidthAdaptation: true,\n      enableLatencyCompensation: true,\n      enableDataSaving: true,\n      enableProgressiveLoading: true\n    }],\n    \n    ['slow', {\n      id: 'slow',\n      name: 'Slow',\n      description: '2G/Poor connection (<1 Mbps)',\n      maxParticleCount: 6,\n      maxFrameRate: 30,\n      textureQuality: 'low',\n      enablePreloading: false,\n      enableCaching: true,\n      enableCompression: true,\n      enableLazyLoading: true,\n      maxDataBudget: 10,\n      enableOfflineMode: true,\n      enableComplexAnimations: false,\n      enableTransitions: false,\n      enableBackgroundAnimations: false,\n      maxAnimationDuration: 3000,\n      enableBandwidthAdaptation: true,\n      enableLatencyCompensation: true,\n      enableDataSaving: true,\n      enableProgressiveLoading: true\n    }],\n    \n    ['data-saver', {\n      id: 'data-saver',\n      name: 'Data Saver',\n      description: 'Minimal data usage mode',\n      maxParticleCount: 4,\n      maxFrameRate: 20,\n      textureQuality: 'low',\n      enablePreloading: false,\n      enableCaching: true,\n      enableCompression: true,\n      enableLazyLoading: true,\n      maxDataBudget: 5,\n      enableOfflineMode: true,\n      enableComplexAnimations: false,\n      enableTransitions: false,\n      enableBackgroundAnimations: false,\n      maxAnimationDuration: 2000,\n      enableBandwidthAdaptation: true,\n      enableLatencyCompensation: true,\n      enableDataSaving: true,\n      enableProgressiveLoading: true\n    }],\n    \n    ['offline', {\n      id: 'offline',\n      name: 'Offline',\n      description: 'No network connection',\n      maxParticleCount: 8,\n      maxFrameRate: 30,\n      textureQuality: 'medium',\n      enablePreloading: false,\n      enableCaching: true,\n      enableCompression: false,\n      enableLazyLoading: false,\n      maxDataBudget: 0,\n      enableOfflineMode: true,\n      enableComplexAnimations: true,\n      enableTransitions: true,\n      enableBackgroundAnimations: true,\n      maxAnimationDuration: 6000,\n      enableBandwidthAdaptation: false,\n      enableLatencyCompensation: false,\n      enableDataSaving: false,\n      enableProgressiveLoading: false\n    }]\n  ]);\n  \n  private constructor() {\n    this.sessionStartTime = Date.now();\n    this.dataUsageMetrics = this.initializeDataUsageMetrics();\n    this.currentProfile = this.profiles.get('medium')!; // Default profile\n    this.setupConnectionMonitoring();\n  }\n  \n  static getInstance(): ConnectionAwareOptimizer {\n    if (!this.instance) {\n      this.instance = new ConnectionAwareOptimizer();\n    }\n    return this.instance;\n  }\n  \n  /**\n   * Initialize data usage metrics\n   */\n  private initializeDataUsageMetrics(): DataUsageMetrics {\n    return {\n      totalBytes: 0,\n      sessionBytes: 0,\n      animationBytes: 0,\n      assetBytes: 0,\n      compressionRatio: 1.0\n    };\n  }\n  \n  /**\n   * Setup connection monitoring\n   */\n  private setupConnectionMonitoring(): void {\n    // Monitor connection changes\n    if ('connection' in navigator) {\n      const connection = (navigator as any).connection;\n      if (connection) {\n        const updateConnection = () => {\n          this.updateConnectionMetrics();\n          this.adaptToConnection();\n        };\n        \n        connection.addEventListener('change', updateConnection);\n        updateConnection(); // Initial check\n      }\n    }\n    \n    // Monitor online/offline status\n    window.addEventListener('online', () => {\n      this.updateConnectionMetrics();\n      this.adaptToConnection();\n    });\n    \n    window.addEventListener('offline', () => {\n      this.setProfile('offline');\n    });\n    \n    // Periodic connection quality checks\n    this.connectionMonitorInterval = window.setInterval(() => {\n      this.performBandwidthTest();\n    }, 30000); // Every 30 seconds\n    \n    // Data usage monitoring\n    this.dataUsageCheckInterval = window.setInterval(() => {\n      this.updateDataUsageMetrics();\n    }, 10000); // Every 10 seconds\n  }\n  \n  /**\n   * Update connection metrics\n   */\n  private updateConnectionMetrics(): void {\n    if ('connection' in navigator) {\n      const connection = (navigator as any).connection;\n      if (connection) {\n        this.connectionMetrics = {\n          effectiveType: connection.effectiveType || '4g',\n          downlink: connection.downlink || 10,\n          uplink: connection.uplink,\n          rtt: connection.rtt || 100,\n          saveData: connection.saveData || false,\n          type: connection.type\n        };\n      }\n    }\n    \n    // Fallback for browsers without Network Information API\n    if (!this.connectionMetrics) {\n      this.connectionMetrics = {\n        effectiveType: '4g',\n        downlink: 10,\n        rtt: 100,\n        saveData: false\n      };\n    }\n  }\n  \n  /**\n   * Perform bandwidth test to verify actual connection quality\n   */\n  private async performBandwidthTest(): Promise<number> {\n    const now = Date.now();\n    if (now - this.lastBandwidthTest < 60000) { // Test at most once per minute\n      return this.bandwidthHistory[this.bandwidthHistory.length - 1] || 0;\n    }\n    \n    try {\n      const testStart = performance.now();\n      \n      // Create a small test request (1x1 pixel image with cache busting)\n      const testUrl = `data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7?t=${now}`;\n      \n      const response = await fetch(testUrl, {\n        method: 'GET',\n        cache: 'no-cache'\n      });\n      \n      if (response.ok) {\n        await response.blob();\n        const testEnd = performance.now();\n        const latency = testEnd - testStart;\n        \n        // Estimate bandwidth based on latency (rough approximation)\n        let estimatedBandwidth: number;\n        if (latency < 50) {\n          estimatedBandwidth = 50; // Very fast\n        } else if (latency < 100) {\n          estimatedBandwidth = 25; // Fast\n        } else if (latency < 200) {\n          estimatedBandwidth = 10; // Medium\n        } else if (latency < 500) {\n          estimatedBandwidth = 3; // Slow\n        } else {\n          estimatedBandwidth = 1; // Very slow\n        }\n        \n        this.bandwidthHistory.push(estimatedBandwidth);\n        if (this.bandwidthHistory.length > 10) {\n          this.bandwidthHistory.shift();\n        }\n        \n        this.lastBandwidthTest = now;\n        return estimatedBandwidth;\n      }\n    } catch (error) {\n      // Test failed, assume slow connection\n      return 1;\n    }\n    \n    return 0;\n  }\n  \n  /**\n   * Adapt to current connection quality\n   */\n  private adaptToConnection(): void {\n    if (!this.connectionMetrics) return;\n    \n    const { effectiveType, downlink, saveData } = this.connectionMetrics;\n    \n    // Force data saver mode if requested\n    if (saveData) {\n      this.setProfile('data-saver');\n      return;\n    }\n    \n    // Determine profile based on connection quality\n    let profileId: string;\n    \n    if (effectiveType === 'slow-2g' || effectiveType === '2g') {\n      profileId = 'slow';\n    } else if (effectiveType === '3g') {\n      profileId = downlink > 5 ? 'medium' : 'slow';\n    } else if (effectiveType === '4g') {\n      if (downlink > 50) {\n        profileId = 'ultra-fast';\n      } else if (downlink > 10) {\n        profileId = 'fast';\n      } else {\n        profileId = 'medium';\n      }\n    } else {\n      profileId = 'medium'; // Default\n    }\n    \n    // Consider bandwidth test results\n    if (this.bandwidthHistory.length > 0) {\n      const avgBandwidth = this.bandwidthHistory.reduce((a, b) => a + b) / this.bandwidthHistory.length;\n      \n      if (avgBandwidth < 2 && profileId !== 'slow') {\n        profileId = 'slow';\n      } else if (avgBandwidth > 30 && profileId === 'slow') {\n        profileId = 'medium';\n      }\n    }\n    \n    this.setProfile(profileId);\n  }\n  \n  /**\n   * Set connection profile\n   */\n  setProfile(profileId: string): void {\n    const profile = this.profiles.get(profileId);\n    if (profile) {\n      this.currentProfile = profile;\n      console.log(`Connection profile changed to: ${profile.name}`);\n    }\n  }\n  \n  /**\n   * Get current connection profile\n   */\n  getCurrentProfile(): ConnectionProfile {\n    return { ...this.currentProfile };\n  }\n  \n  /**\n   * Get all available profiles\n   */\n  getAvailableProfiles(): ConnectionProfile[] {\n    return Array.from(this.profiles.values());\n  }\n  \n  /**\n   * Update data usage metrics\n   */\n  private updateDataUsageMetrics(): void {\n    if ('memory' in performance) {\n      const memory = (performance as any).memory;\n      if (memory) {\n        // Estimate data usage based on memory usage (rough approximation)\n        const currentHeapSize = memory.usedJSHeapSize;\n        const sessionDuration = (Date.now() - this.sessionStartTime) / 1000 / 60; // minutes\n        \n        this.dataUsageMetrics.sessionBytes = currentHeapSize;\n        \n        // Estimate network data usage (very rough)\n        this.dataUsageMetrics.totalBytes = currentHeapSize * 0.1; // Assume 10% of heap is network data\n      }\n    }\n  }\n  \n  /**\n   * Track animation data usage\n   */\n  trackAnimationDataUsage(bytes: number): void {\n    this.dataUsageMetrics.animationBytes += bytes;\n    this.dataUsageMetrics.totalBytes += bytes;\n    \n    // Check data budget\n    const budgetMB = this.currentProfile.maxDataBudget;\n    const usageMB = this.dataUsageMetrics.sessionBytes / (1024 * 1024);\n    \n    if (usageMB > budgetMB * 0.8) { // 80% of budget used\n      console.warn('Approaching data budget limit');\n      if (this.currentProfile.id !== 'data-saver') {\n        this.setProfile('data-saver');\n      }\n    }\n  }\n  \n  /**\n   * Track asset data usage\n   */\n  trackAssetDataUsage(bytes: number): void {\n    this.dataUsageMetrics.assetBytes += bytes;\n    this.dataUsageMetrics.totalBytes += bytes;\n  }\n  \n  /**\n   * Optimize mobile settings based on connection\n   */\n  optimizeMobileSettings(baseSettings: MobileOptimizationSettings): MobileOptimizationSettings {\n    const profile = this.currentProfile;\n    \n    return {\n      ...baseSettings,\n      \n      // Animation optimizations\n      maxParticleCount: Math.min(baseSettings.maxParticleCount, profile.maxParticleCount),\n      preferredFrameRate: Math.min(baseSettings.preferredFrameRate, profile.maxFrameRate),\n      \n      // Data optimizations\n      enableDataSaving: profile.enableDataSaving || baseSettings.enableDataSaving,\n      preloadAnimations: profile.enablePreloading && baseSettings.preloadAnimations,\n      \n      // Quality optimizations\n      maxTextureResolution: this.getOptimalTextureResolution(baseSettings.maxTextureResolution),\n      maxPixelDensity: this.getOptimalPixelDensity(baseSettings.maxPixelDensity)\n    };\n  }\n  \n  /**\n   * Get optimal texture resolution based on connection\n   */\n  private getOptimalTextureResolution(baseResolution: number): number {\n    const profile = this.currentProfile;\n    \n    switch (profile.textureQuality) {\n      case 'low':\n        return Math.min(baseResolution, 1024);\n      case 'medium':\n        return Math.min(baseResolution, 2048);\n      case 'high':\n        return baseResolution;\n      default:\n        return baseResolution;\n    }\n  }\n  \n  /**\n   * Get optimal pixel density based on connection\n   */\n  private getOptimalPixelDensity(baseDensity: number): number {\n    const profile = this.currentProfile;\n    \n    if (profile.enableDataSaving) {\n      return Math.min(baseDensity, 1.5); // Reduce pixel density for data saving\n    }\n    \n    return baseDensity;\n  }\n  \n  /**\n   * Should enable feature based on connection profile\n   */\n  shouldEnableFeature(feature: keyof ConnectionProfile): boolean {\n    return Boolean(this.currentProfile[feature]);\n  }\n  \n  /**\n   * Get connection quality insights\n   */\n  getConnectionInsights(): {\n    quality: 'excellent' | 'good' | 'fair' | 'poor';\n    latency: 'low' | 'medium' | 'high';\n    stability: 'stable' | 'unstable';\n    dataUsage: 'low' | 'medium' | 'high';\n    recommendations: string[];\n  } {\n    const metrics = this.connectionMetrics;\n    const profile = this.currentProfile;\n    const recommendations: string[] = [];\n    \n    if (!metrics) {\n      return {\n        quality: 'fair',\n        latency: 'medium',\n        stability: 'stable',\n        dataUsage: 'medium',\n        recommendations: ['Unable to detect connection quality']\n      };\n    }\n    \n    // Determine quality\n    let quality: 'excellent' | 'good' | 'fair' | 'poor';\n    if (metrics.downlink > 50) {\n      quality = 'excellent';\n    } else if (metrics.downlink > 10) {\n      quality = 'good';\n    } else if (metrics.downlink > 1) {\n      quality = 'fair';\n    } else {\n      quality = 'poor';\n    }\n    \n    // Determine latency\n    let latency: 'low' | 'medium' | 'high';\n    if (metrics.rtt < 100) {\n      latency = 'low';\n    } else if (metrics.rtt < 300) {\n      latency = 'medium';\n    } else {\n      latency = 'high';\n    }\n    \n    // Determine stability based on bandwidth history variance\n    let stability: 'stable' | 'unstable' = 'stable';\n    if (this.bandwidthHistory.length > 3) {\n      const avg = this.bandwidthHistory.reduce((a, b) => a + b) / this.bandwidthHistory.length;\n      const variance = this.bandwidthHistory.reduce((acc, val) => acc + Math.pow(val - avg, 2), 0) / this.bandwidthHistory.length;\n      \n      if (variance > avg * 0.5) { // High variance indicates instability\n        stability = 'unstable';\n        recommendations.push('Connection appears unstable, using conservative settings');\n      }\n    }\n    \n    // Determine data usage\n    const usageMB = this.dataUsageMetrics.sessionBytes / (1024 * 1024);\n    let dataUsage: 'low' | 'medium' | 'high';\n    if (usageMB < 5) {\n      dataUsage = 'low';\n    } else if (usageMB < 20) {\n      dataUsage = 'medium';\n    } else {\n      dataUsage = 'high';\n      recommendations.push('High data usage detected, consider enabling data saver mode');\n    }\n    \n    // Generate recommendations\n    if (quality === 'poor') {\n      recommendations.push('Slow connection detected, reducing animation complexity');\n    }\n    \n    if (latency === 'high') {\n      recommendations.push('High latency detected, enabling latency compensation');\n    }\n    \n    if (metrics.saveData) {\n      recommendations.push('Data saver mode enabled, optimizing for minimal data usage');\n    }\n    \n    if (profile.id === 'offline') {\n      recommendations.push('Offline mode active, using cached content only');\n    }\n    \n    return {\n      quality,\n      latency,\n      stability,\n      dataUsage,\n      recommendations\n    };\n  }\n  \n  /**\n   * Get current connection metrics\n   */\n  getConnectionMetrics(): ConnectionMetrics | null {\n    return this.connectionMetrics ? { ...this.connectionMetrics } : null;\n  }\n  \n  /**\n   * Get current data usage metrics\n   */\n  getDataUsageMetrics(): DataUsageMetrics {\n    return { ...this.dataUsageMetrics };\n  }\n  \n  /**\n   * Reset data usage for new session\n   */\n  resetDataUsage(): void {\n    this.dataUsageMetrics = this.initializeDataUsageMetrics();\n    this.sessionStartTime = Date.now();\n  }\n  \n  /**\n   * Cleanup and stop monitoring\n   */\n  cleanup(): void {\n    if (this.connectionMonitorInterval) {\n      clearInterval(this.connectionMonitorInterval);\n    }\n    \n    if (this.dataUsageCheckInterval) {\n      clearInterval(this.dataUsageCheckInterval);\n    }\n  }\n}\n\n// Global connection-aware optimizer instance\nexport const connectionAwareOptimizer = ConnectionAwareOptimizer.getInstance();\n\n/**\n * Convenience functions\n */\nexport const getCurrentConnectionProfile = (): ConnectionProfile => {\n  return connectionAwareOptimizer.getCurrentProfile();\n};\n\nexport const optimizeForConnection = (baseSettings: MobileOptimizationSettings): MobileOptimizationSettings => {\n  return connectionAwareOptimizer.optimizeMobileSettings(baseSettings);\n};\n\nexport const shouldEnableConnectionFeature = (feature: keyof ConnectionProfile): boolean => {\n  return connectionAwareOptimizer.shouldEnableFeature(feature);\n};\n\nexport const getConnectionQuality = (): 'excellent' | 'good' | 'fair' | 'poor' => {\n  return connectionAwareOptimizer.getConnectionInsights().quality;\n};