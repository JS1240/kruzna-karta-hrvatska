/**
 * Fallback Animation System for Low-Performance Devices (T5.2)
 * 
 * Provides CSS-based and static background alternatives when WebGL
 * animations are not suitable for the device or performance constraints.
 * 
 * Features:
 * - CSS particle animation system
 * - Gradient-based animations
 * - Static pattern generators
 * - Brand-consistent fallback designs
 * - Performance-optimized implementations
 */

import { BRAND_COLORS } from './colorUtils';
import type { DeviceCapabilities, FallbackRecommendation } from './deviceDetection';

export type FallbackMode = 'webgl' | 'css' | 'static' | 'none';
export type CSSAnimationType = 'particles' | 'gradients' | 'minimal';
export type StaticPatternType = 'geometric' | 'brand' | 'solid';

export interface FallbackAnimationConfig {
  mode: FallbackMode;
  cssAnimationType: CSSAnimationType;
  staticPatternType: StaticPatternType;
  enableTransitions: boolean;
  colors: {
    primary: string;
    secondary: string;
    accent1: string;
    accent2: string;
  };
  intensity: number; // 0-1
  opacity: number; // 0-1
  speed: number; // 0-1
  particleCount: number;
  id?: string;
}

export interface CSSParticleConfig {
  count: number;
  size: { min: number; max: number };
  speed: { min: number; max: number };
  opacity: { min: number; max: number };
  colors: string[];
  animation: {
    duration: { min: number; max: number };
    delay: { min: number; max: number };
    direction: 'normal' | 'reverse' | 'alternate';
    timing: string;
  };
}

export interface GradientAnimationConfig {
  colors: string[];
  direction: number; // degrees
  animationDuration: number;
  keyframes: number;
  blur: number;
  opacity: number;
}

export interface StaticPatternConfig {
  type: StaticPatternType;
  colors: string[];
  opacity: number;
  pattern: {
    size: number;
    spacing: number;
    angle: number;
  };
}

/**
 * CSS-based fallback animation manager
 */
export class FallbackAnimationManager {
  private animationElements: Map<string, HTMLElement[]> = new Map();
  private animationIds: Map<string, number[]> = new Map();
  private isAnimating: Map<string, boolean> = new Map();
  
  /**
   * Initialize CSS particle animation
   */
  initializeParticleAnimation(\n    container: HTMLElement,\n    config: CSSParticleConfig,\n    animationId: string = 'default'\n  ): void {\n    this.cleanup(animationId);\n    \n    const particles: HTMLElement[] = [];\n    \n    for (let i = 0; i < config.count; i++) {\n      const particle = this.createParticle(config, i);\n      container.appendChild(particle);\n      particles.push(particle);\n    }\n    \n    this.animationElements.set(animationId, particles);\n    this.isAnimating.set(animationId, true);\n    \n    // Store animation for cleanup\n    const animationFrameId = requestAnimationFrame(() => {\n      this.updateParticleAnimations(animationId, config);\n    });\n    \n    this.animationIds.set(animationId, [animationFrameId]);\n  }\n  \n  /**\n   * Initialize CSS gradient animation\n   */\n  initializeGradientAnimation(\n    container: HTMLElement,\n    config: GradientAnimationConfig,\n    animationId: string = 'default'\n  ): void {\n    this.cleanup(animationId);\n    \n    // Create gradient animation element\n    const gradientElement = document.createElement('div');\n    gradientElement.className = 'fallback-gradient-animation';\n    \n    // Apply gradient animation styles\n    this.applyGradientAnimation(gradientElement, config);\n    \n    container.appendChild(gradientElement);\n    this.animationElements.set(animationId, [gradientElement]);\n    this.isAnimating.set(animationId, true);\n  }\n  \n  /**\n   * Initialize static pattern background\n   */\n  initializeStaticPattern(\n    container: HTMLElement,\n    config: StaticPatternConfig,\n    animationId: string = 'default'\n  ): void {\n    this.cleanup(animationId);\n    \n    const patternElement = document.createElement('div');\n    patternElement.className = 'fallback-static-pattern';\n    \n    // Apply static pattern styles\n    this.applyStaticPattern(patternElement, config);\n    \n    container.appendChild(patternElement);\n    this.animationElements.set(animationId, [patternElement]);\n    this.isAnimating.set(animationId, false);\n  }\n  \n  /**\n   * Create individual particle element\n   */\n  private createParticle(config: CSSParticleConfig, index: number): HTMLElement {\n    const particle = document.createElement('div');\n    particle.className = 'fallback-particle';\n    \n    // Random particle properties\n    const size = this.randomBetween(config.size.min, config.size.max);\n    const speed = this.randomBetween(config.speed.min, config.speed.max);\n    const opacity = this.randomBetween(config.opacity.min, config.opacity.max);\n    const color = config.colors[Math.floor(Math.random() * config.colors.length)];\n    const duration = this.randomBetween(config.animation.duration.min, config.animation.duration.max);\n    const delay = this.randomBetween(config.animation.delay.min, config.animation.delay.max);\n    \n    // Random starting position\n    const startX = Math.random() * 100;\n    const startY = Math.random() * 100;\n    \n    // Apply styles\n    Object.assign(particle.style, {\n      position: 'absolute',\n      width: `${size}px`,\n      height: `${size}px`,\n      backgroundColor: color,\n      borderRadius: '50%',\n      opacity: opacity.toString(),\n      left: `${startX}%`,\n      top: `${startY}%`,\n      pointerEvents: 'none',\n      willChange: 'transform, opacity',\n      transform: 'translate3d(0, 0, 0)', // Enable hardware acceleration\n      animation: `fallback-particle-${index % 3} ${duration}s ${config.animation.timing} ${delay}s infinite ${config.animation.direction}`\n    });\n    \n    return particle;\n  }\n  \n  /**\n   * Update particle animations\n   */\n  private updateParticleAnimations(animationId: string, config: CSSParticleConfig): void {\n    if (!this.isAnimating.get(animationId)) return;\n    \n    const particles = this.animationElements.get(animationId) || [];\n    \n    particles.forEach((particle, index) => {\n      // Periodically update particle positions for more dynamic movement\n      if (Math.random() < 0.001) { // 0.1% chance per frame\n        const newX = Math.random() * 100;\n        const newY = Math.random() * 100;\n        particle.style.left = `${newX}%`;\n        particle.style.top = `${newY}%`;\n      }\n    });\n    \n    // Continue animation loop\n    const animationFrameId = requestAnimationFrame(() => {\n      this.updateParticleAnimations(animationId, config);\n    });\n    \n    const currentIds = this.animationIds.get(animationId) || [];\n    this.animationIds.set(animationId, [...currentIds, animationFrameId]);\n  }\n  \n  /**\n   * Apply gradient animation styles\n   */\n  private applyGradientAnimation(element: HTMLElement, config: GradientAnimationConfig): void {\n    const gradientStops = config.colors.map((color, index) => {\n      const position = (index / (config.colors.length - 1)) * 100;\n      return `${color} ${position}%`;\n    }).join(', ');\n    \n    Object.assign(element.style, {\n      position: 'absolute',\n      top: '0',\n      left: '0',\n      width: '100%',\n      height: '100%',\n      background: `linear-gradient(${config.direction}deg, ${gradientStops})`,\n      opacity: config.opacity.toString(),\n      pointerEvents: 'none',\n      willChange: 'transform',\n      filter: config.blur > 0 ? `blur(${config.blur}px)` : 'none',\n      animation: `fallback-gradient-shift ${config.animationDuration}s ease-in-out infinite alternate`\n    });\n  }\n  \n  /**\n   * Apply static pattern styles\n   */\n  private applyStaticPattern(element: HTMLElement, config: StaticPatternConfig): void {\n    Object.assign(element.style, {\n      position: 'absolute',\n      top: '0',\n      left: '0',\n      width: '100%',\n      height: '100%',\n      opacity: config.opacity.toString(),\n      pointerEvents: 'none',\n      ...this.generatePatternStyles(config)\n    });\n  }\n  \n  /**\n   * Generate pattern styles based on type\n   */\n  private generatePatternStyles(config: StaticPatternConfig): { [key: string]: string } {\n    const { colors, pattern } = config;\n    \n    switch (config.type) {\n      case 'geometric':\n        return {\n          background: `\n            radial-gradient(circle at 25% 25%, ${colors[0]}40 0%, transparent 50%),\n            radial-gradient(circle at 75% 75%, ${colors[1]}30 0%, transparent 50%),\n            linear-gradient(45deg, ${colors[0]}10 25%, transparent 25%, transparent 75%, ${colors[1]}10 75%)\n          `,\n          backgroundSize: `${pattern.size}px ${pattern.size}px, ${pattern.size}px ${pattern.size}px, ${pattern.spacing}px ${pattern.spacing}px`\n        };\n        \n      case 'brand':\n        return {\n          background: `\n            linear-gradient(135deg, ${colors[0]}20 0%, transparent 50%, ${colors[1]}15 100%),\n            radial-gradient(ellipse at center, ${colors[0]}10 0%, transparent 70%)\n          `,\n          backgroundSize: '100% 100%, 50% 50%'\n        };\n        \n      case 'solid':\n      default:\n        return {\n          background: `linear-gradient(135deg, ${colors[0]}15, ${colors[1]}10)`\n        };\n    }\n  }\n  \n  /**\n   * Stop animation for specific ID\n   */\n  stop(animationId: string): void {\n    this.isAnimating.set(animationId, false);\n    \n    const animationIds = this.animationIds.get(animationId) || [];\n    animationIds.forEach(id => cancelAnimationFrame(id));\n    this.animationIds.delete(animationId);\n  }\n  \n  /**\n   * Cleanup animation elements and resources\n   */\n  cleanup(animationId: string): void {\n    this.stop(animationId);\n    \n    const elements = this.animationElements.get(animationId) || [];\n    elements.forEach(element => {\n      if (element.parentNode) {\n        element.parentNode.removeChild(element);\n      }\n    });\n    \n    this.animationElements.delete(animationId);\n  }\n  \n  /**\n   * Cleanup all animations\n   */\n  cleanupAll(): void {\n    const allIds = Array.from(this.animationElements.keys());\n    allIds.forEach(id => this.cleanup(id));\n  }\n  \n  /**\n   * Check if animation is running\n   */\n  isRunning(animationId: string): boolean {\n    return this.isAnimating.get(animationId) || false;\n  }\n  \n  /**\n   * Utility: Random number between min and max\n   */\n  private randomBetween(min: number, max: number): number {\n    return Math.random() * (max - min) + min;\n  }\n}\n\n/**\n * Fallback configuration generator\n */\nexport class FallbackConfigGenerator {\n  /**\n   * Generate CSS particle configuration\n   */\n  static generateParticleConfig(\n    recommendation: FallbackRecommendation,\n    colors: string[] = [BRAND_COLORS.primary, BRAND_COLORS.secondary]\n  ): CSSParticleConfig {\n    const { performanceSettings } = recommendation;\n    \n    return {\n      count: Math.max(1, performanceSettings.particleCount),\n      size: { min: 2, max: 6 },\n      speed: { min: 0.5, max: 2 },\n      opacity: { min: 0.1, max: performanceSettings.opacity },\n      colors,\n      animation: {\n        duration: { min: 8, max: 20 },\n        delay: { min: 0, max: 5 },\n        direction: 'alternate',\n        timing: 'ease-in-out'\n      }\n    };\n  }\n  \n  /**\n   * Generate gradient animation configuration\n   */\n  static generateGradientConfig(\n    recommendation: FallbackRecommendation,\n    colors: string[] = [BRAND_COLORS.primary, BRAND_COLORS.secondary, BRAND_COLORS.accent1]\n  ): GradientAnimationConfig {\n    return {\n      colors,\n      direction: 135,\n      animationDuration: 12,\n      keyframes: 3,\n      blur: 0,\n      opacity: recommendation.performanceSettings.opacity\n    };\n  }\n  \n  /**\n   * Generate static pattern configuration\n   */\n  static generateStaticPatternConfig(\n    recommendation: FallbackRecommendation,\n    colors: string[] = [BRAND_COLORS.primary, BRAND_COLORS.secondary]\n  ): StaticPatternConfig {\n    return {\n      type: recommendation.staticPatternType,\n      colors,\n      opacity: recommendation.performanceSettings.opacity,\n      pattern: {\n        size: 40,\n        spacing: 60,\n        angle: 45\n      }\n    };\n  }\n  \n  /**\n   * Generate complete fallback configuration\n   */\n  static generateFallbackConfig(\n    recommendation: FallbackRecommendation,\n    customColors?: {\n      primary?: string;\n      secondary?: string;\n      accent1?: string;\n      accent2?: string;\n    }\n  ): FallbackAnimationConfig {\n    const colors = {\n      primary: customColors?.primary || BRAND_COLORS.primary,\n      secondary: customColors?.secondary || BRAND_COLORS.secondary,\n      accent1: customColors?.accent1 || BRAND_COLORS.accent1,\n      accent2: customColors?.accent2 || BRAND_COLORS.accent2\n    };\n    \n    return {\n      mode: recommendation.mode,\n      cssAnimationType: recommendation.cssAnimationType,\n      staticPatternType: recommendation.staticPatternType,\n      enableTransitions: recommendation.enableTransitions,\n      colors,\n      intensity: recommendation.performanceSettings.particleCount / 16, // Normalized to 0-1\n      opacity: recommendation.performanceSettings.opacity,\n      speed: recommendation.performanceSettings.updateFrequency / 60, // Normalized to 0-1\n      particleCount: recommendation.performanceSettings.particleCount\n    };\n  }\n}\n\n/**\n * CSS keyframes injector for fallback animations\n */\nexport class FallbackStylesInjector {\n  private static injected = false;\n  private static styleElement: HTMLStyleElement | null = null;\n  \n  /**\n   * Inject CSS keyframes and styles\n   */\n  static injectStyles(): void {\n    if (this.injected) return;\n    \n    this.styleElement = document.createElement('style');\n    this.styleElement.textContent = this.generateCSS();\n    document.head.appendChild(this.styleElement);\n    this.injected = true;\n  }\n  \n  /**\n   * Remove injected styles\n   */\n  static removeStyles(): void {\n    if (this.styleElement && this.styleElement.parentNode) {\n      this.styleElement.parentNode.removeChild(this.styleElement);\n      this.styleElement = null;\n      this.injected = false;\n    }\n  }\n  \n  /**\n   * Generate CSS for fallback animations\n   */\n  private static generateCSS(): string {\n    return `\n      /* Fallback Particle Animations */\n      @keyframes fallback-particle-0 {\n        0% { transform: translate3d(0, 0, 0) rotate(0deg); }\n        25% { transform: translate3d(10px, -15px, 0) rotate(90deg); }\n        50% { transform: translate3d(-5px, -25px, 0) rotate(180deg); }\n        75% { transform: translate3d(-15px, -10px, 0) rotate(270deg); }\n        100% { transform: translate3d(0, 0, 0) rotate(360deg); }\n      }\n      \n      @keyframes fallback-particle-1 {\n        0% { transform: translate3d(0, 0, 0) scale(1); opacity: 0.3; }\n        33% { transform: translate3d(20px, 10px, 0) scale(0.8); opacity: 0.7; }\n        66% { transform: translate3d(-10px, 20px, 0) scale(1.2); opacity: 0.4; }\n        100% { transform: translate3d(0, 0, 0) scale(1); opacity: 0.3; }\n      }\n      \n      @keyframes fallback-particle-2 {\n        0% { transform: translate3d(0, 0, 0) rotateX(0deg); }\n        50% { transform: translate3d(-20px, 15px, 0) rotateX(180deg); }\n        100% { transform: translate3d(0, 0, 0) rotateX(360deg); }\n      }\n      \n      /* Fallback Gradient Animation */\n      @keyframes fallback-gradient-shift {\n        0% { transform: translate3d(-5%, -5%, 0) scale(1.1); }\n        100% { transform: translate3d(5%, 5%, 0) scale(1.05); }\n      }\n      \n      /* Fallback Container Styles */\n      .fallback-particle {\n        transition: opacity 0.3s ease, transform 0.3s ease;\n      }\n      \n      .fallback-gradient-animation {\n        transition: opacity 0.5s ease;\n      }\n      \n      .fallback-static-pattern {\n        transition: opacity 0.5s ease;\n      }\n      \n      /* Reduced motion support */\n      @media (prefers-reduced-motion: reduce) {\n        .fallback-particle {\n          animation: none !important;\n        }\n        \n        .fallback-gradient-animation {\n          animation: none !important;\n        }\n      }\n    `;\n  }\n}\n\n// Global fallback animation manager instance\nexport const fallbackAnimationManager = new FallbackAnimationManager();\n\n/**\n * Convenience functions\n */\nexport const initializeFallbackAnimation = (\n  container: HTMLElement,\n  recommendation: FallbackRecommendation,\n  customColors?: {\n    primary?: string;\n    secondary?: string;\n    accent1?: string;\n    accent2?: string;\n  },\n  animationId: string = 'default'\n): void => {\n  // Inject CSS styles if not already done\n  FallbackStylesInjector.injectStyles();\n  \n  const config = FallbackConfigGenerator.generateFallbackConfig(recommendation, customColors);\n  const colors = [config.colors.primary, config.colors.secondary];\n  \n  switch (recommendation.mode) {\n    case 'css':\n      if (recommendation.cssAnimationType === 'particles') {\n        const particleConfig = FallbackConfigGenerator.generateParticleConfig(recommendation, colors);\n        fallbackAnimationManager.initializeParticleAnimation(container, particleConfig, animationId);\n      } else {\n        const gradientConfig = FallbackConfigGenerator.generateGradientConfig(recommendation, colors);\n        fallbackAnimationManager.initializeGradientAnimation(container, gradientConfig, animationId);\n      }\n      break;\n      \n    case 'static':\n      const staticConfig = FallbackConfigGenerator.generateStaticPatternConfig(recommendation, colors);\n      fallbackAnimationManager.initializeStaticPattern(container, staticConfig, animationId);\n      break;\n      \n    default:\n      // No animation\n      break;\n  }\n};\n\nexport const stopFallbackAnimation = (animationId: string = 'default'): void => {\n  fallbackAnimationManager.stop(animationId);\n};\n\nexport const cleanupFallbackAnimation = (animationId: string = 'default'): void => {\n  fallbackAnimationManager.cleanup(animationId);\n};\n\nexport const cleanupAllFallbackAnimations = (): void => {\n  fallbackAnimationManager.cleanupAll();\n};